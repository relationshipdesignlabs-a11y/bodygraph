<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Bodygraph Deploy Diagnostics</title>
<style>
  body{font-family: ui-sans-serif, -apple-system, Segoe UI, Roboto, Arial, sans-serif; padding:24px; color:#0a0f12}
  h1{margin:0 0 8px} .muted{color:#6b7280}
  table{border-collapse:collapse; width:100%; margin-top:16px}
  th,td{border:1px solid #e5e7eb; padding:8px; font-size:14px}
  th{background:#f8fafc; text-align:left}
  code{background:#f3f4f6; padding:2px 6px; border-radius:6px}
  .ok{color:#16a34a; font-weight:700}
  .bad{color:#dc2626; font-weight:700}
  .warn{color:#d97706; font-weight:700}
  .grid{display:grid; grid-template-columns:1fr 1fr; gap:16px; margin-top:24px}
  iframe{width:100%; height:600px; border:1px solid #e5e7eb; border-radius:8px}
</style>
</head>
<body>
  <h1>Bodygraph Deploy Diagnostics</h1>
  <div class="muted">Checks whether your deployed files exist, their sizes, and shows quick previews.</div>

  <table id="tbl">
    <thead><tr><th>Path</th><th>Status</th><th>Size</th><th>Last-Modified</th><th>ETag</th></tr></thead>
    <tbody></tbody>
  </table>

  <div class="grid">
    <div>
      <h3>Embedded WORKING.html (what the iframe loads)</h3>
      <iframe id="ifWorking" src="/WORKING.html?v=diag1"></iframe>
    </div>
    <div>
      <h3>Main index.html</h3>
      <iframe id="ifIndex" src="/index.html?v=diag1"></iframe>
    </div>
  </div>

<script>
const paths = [
  "/index.html",
  "/WORKING.html",
  "/details.html",
  "/bodygraph-layout.json",
  "/integration-patch-v3.js",
  "/integration-patch-v2.js",
  "/integration-patch.js",
  "/WORKING-prod-v3.html",
  "/index-fullscreen-v3.html",
  "/index-fullscreen-v2.html",
  "/index-v34.html",
  "/WORKING-v3.html",
  "/WORKING-inline-ab-v2.html",
  "/WORKING-inline-ab.html"
];

async function fetchHeadOrGet(url){
  // Try HEAD first; if blocked, fallback to GET (no-store) and read headers.
  try{
    let r = await fetch(url, { method:"HEAD", cache:"no-store" });
    if (!r.ok) throw new Error("HEAD not ok");
    return { ok:r.ok, status:r.status, len:r.headers.get("content-length")||"", lm:r.headers.get("last-modified")||"", etag:r.headers.get("etag")||"" };
  }catch(e){
    try{
      let r = await fetch(url + (url.includes("?") ? "&" : "?") + "probe=headfall", { method:"GET", cache:"no-store" });
      return { ok:r.ok, status:r.status, len:r.headers.get("content-length")||"", lm:r.headers.get("last-modified")||"", etag:r.headers.get("etag")||"" };
    }catch(e2){
      return { ok:false, status:"ERR", len:"", lm:"", etag:"" };
    }
  }
}

(async ()=>{
  const tbody = document.querySelector("#tbl tbody");
  for(const p of paths){
    const r = await fetchHeadOrGet(p);
    const cls = r.ok ? "ok" : (r.status==404 ? "bad" : "warn");
    const tr = document.createElement("tr");
    tr.innerHTML = `<td><code>${p}</code></td>
      <td class="${cls}">${r.ok ? r.status : r.status}</td>
      <td>${r.len||"—"}</td>
      <td>${r.lm||"—"}</td>
      <td>${r.etag||"—"}</td>`;
    tbody.appendChild(tr);
  }
})();
</script>
</body>
</html>
