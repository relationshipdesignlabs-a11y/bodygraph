<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Bodygraph Renderer — Production (No UI)</title>
<style>
  html,body{margin:0;height:100%;background:#fff}
  .wrap{display:flex;align-items:center;justify-content:center;min-height:100%}
  svg{width:100%;max-width:720px;height:auto;display:block}
  .center{fill:#fafafa;stroke:#1a2428;stroke-width:2}
  .channel-base{fill:none;stroke:#b8c3c7;opacity:.55}
  .channel {fill:none;stroke-linecap:round;opacity:.98}
  .channel.design{stroke:#10c3ff}
  .channel.person{stroke:#111}
  .gate circle{fill:#dce2e4;stroke:none}
  .gate text{font:10px ui-sans-serif,system-ui;fill:#111;font-weight:600;dominant-baseline:middle;text-anchor:middle}
</style>
</head>
<body>
<div class="wrap">
  <svg id="svg" viewBox="0 0 720 1080" preserveAspectRatio="xMidYMid meet" aria-label="Human Design Bodygraph">
    <g id="centers"></g>
    <g id="channels-base"></g>
    <g id="channels"></g>
    <g id="gates"></g>
  </svg>
</div>
<script>
const NS='http://www.w3.org/2000/svg';
const svg=document.getElementById('svg');
const gC=document.getElementById('centers');
const gChBase=document.getElementById('channels-base');
const gCh=document.getElementById('channels');
const gG=document.getElementById('gates');
function el(n,attrs,p){const e=document.createElementNS(NS,n);for(const[k,v]of Object.entries(attrs||{}))e.setAttribute(k,v);if(p)p.appendChild(e);return e}
function Q(A,B,C){ return `M ${A[0]},${A[1]} Q ${C[0]},${C[1]} ${B[0]},${B[1]}`; }
function quad(A,C,B,t){ const u=1-t; return [u*u*A[0]+2*u*t*C[0]+t*t*B[0], u*u*A[1]+2*u*t*C[1]+t*t*B[1]]; }
function sample(A,C,B, t1, t2, N=32){ const pts=[]; const steps=Math.max(2, Math.round(N*Math.abs(t2-t1))); for(let i=0;i<=steps;i++){ const t=t1+(i/steps)*(t2-t1); pts.push(quad(A,C,B,t)); } return pts; }
function pathFromPts(pts){ if(!pts||pts.length<2) return ''; let d=`M ${pts[0][0]},${pts[0][1]}`; for(let i=1;i<pts.length;i++){ d+=` L ${pts[i][0]},${pts[i][1]}`; } return d; }

function drawCenters(centers){
  gC.innerHTML='';
  for(const c of centers){
    let node;
    if(c.type==='rect'){ node=el('rect',{x:c.x,y:c.y,width:c.w,height:c.h,rx:c.rx||18,ry:c.rx||18},gC); }
    else if(c.type==='diamond'){ const cx=c.x+c.w/2, cy=c.y+c.h/2; node=el('rect',{x:c.x,y:c.y,width:c.w,height:c.h,rx:20,ry:20,transform:`rotate(${c.rot||0} ${cx} ${cy})`},gC); }
    else if(c.type==='tri'){
      let pts='';
      if(c.dir==='up') pts=`${c.x+c.w/2},${c.y} ${c.x+c.w},${c.y+c.h} ${c.x},${c.y+c.h}`;
      else if(c.dir==='down') pts=`${c.x},${c.y} ${c.x+c.w},${c.y} ${c.x+c.w/2},${c.y+c.h}`;
      else if(c.dir==='left') pts=`${c.x+c.w},${c.y} ${c.x+c.w},${c.y+c.h} ${c.x},${c.y+c.h/2}`;
      else pts=`${c.x},${c.y} ${c.x+c.w},${c.y+c.h/2} ${c.x},${c.y+c.h}`;
      node=el('polygon',{points:pts,transform:`rotate(${c.rot||0} ${c.x+c.w/2} ${c.y+c.h/2})`},gC);
    } else { node=el('rect',{x:c.x,y:c.y,width:c.w,height:c.h,rx:10,ry:10},gC); }
    node.setAttribute('class','center');
  }
}

function drawGates(gates,rad){
  gG.innerHTML='';
  const ids=Object.keys(gates).sort((a,b)=>+a-+b);
  for(const id of ids){
    const [x,y]=gates[id]; const r=(rad&&rad[id])||12;
    const g=el('g',{class:'gate','data-id':id}, gG);
    el('circle',{cx:x,cy:y,r}, g);
    el('text',{x,y,'text-anchor':'middle','font-size':'10','font-weight':'600'}, g).textContent=id;
  }
}

// Math helpers for A/B
function solveQuadForY(A,C,B,y0){
  const Ay=A[1], Cy=C[1], By=B[1];
  const a = Ay - 2*Cy + By;
  const b = -2*Ay + 2*Cy;
  const c = Ay - y0;
  let roots=[];
  if(Math.abs(a) < 1e-9){
    if(Math.abs(b) > 1e-9){ const t = -c/b; if(t>=0 && t<=1) roots.push(t); }
  }else{
    const D=b*b - 4*a*c;
    if(D>=0){ const sD=Math.sqrt(D); const t1=(-b+sD)/(2*a), t2=(-b-sD)/(2*a);
      if(t1>=0 && t1<=1) roots.push(t1);
      if(t2>=0 && t2<=1) roots.push(t2);
    }
  }
  return roots.sort();
}
function findIntersectionWithLine(A,C,B, P0, v){
  function quadPt(t){ const u=1-t; return [u*u*A[0]+2*u*t*C[0]+t*t*B[0], u*u*A[1]+2*u*t*C[1]+t*t*B[1]]; }
  function cross(v, r){ return v[0]*r[1]-v[1]*r[0]; }
  function f(t){ const Q=quadPt(t); const r=[Q[0]-P0[0], Q[1]-P0[1]]; return cross(v,r); }
  let bestT=0, bestVal=1e9;
  for(let i=0;i<=200;i++){ const t=i/200, val=Math.abs(f(t)); if(val<bestVal){ bestVal=val; bestT=t; } }
  let lo=Math.max(0,bestT-0.1), hi=Math.min(1,bestT+0.1);
  for(let k=0;k<30;k++){ const t1=lo+(hi-lo)/3, t2=hi-(hi-lo)/3; const v1=Math.abs(f(t1)), v2=Math.abs(f(t2)); if(v1<v2){ hi=t2; } else { lo=t1; } }
  const t=(lo+hi)/2; const Qp=quadPt(t); return {t, point:Qp};
}

// Core channel drawing with Integration rules and coloring
function drawChannels(layout, defs){
  gChBase.innerHTML=''; gCh.innerHTML='';
  const {gates, channels} = layout;
  const strokeBase = (w)=>({class:'channel-base','stroke-width':w||8});
  const stroke = (w,cls)=>({class:'channel '+cls, 'stroke-width':w||8});

  // First: draw all channels as base
  for(const [key,ch] of Object.entries(channels||{})){
    const A=gates[ch.a], B=gates[ch.b]; if(!A||!B) continue;
    let d;
    if(ch.style==='orth'){
      const midY=(A[1]+B[1])/2;
      d = `M ${A[0]},${A[1]} L ${A[0]},${midY} L ${B[0]},${midY} L ${B[1]}`;
    }else{
      const C=ch.ctrl || [(A[0]+B[0])/2,(A[1]+B[1])/2];
      d = Q(A,B,C);
    }
    el('path', Object.assign({d, 'data-id': [ch.a,ch.b].sort().join('-')}, strokeBase(ch.w)), gChBase);
  }

  const idKey=(a,b)=>[a,b].sort().join('-');
  const has=(g)=>defs.design.has(g) || defs.person.has(g);
  const both=(a,b)=> has(a) && has(b);

  // Build Integration spine from 20–57 with constraints
  const spine = channels[idKey('20','57')];
  if(!spine){ return; }
  const P20=gates['20'], P57=gates['57'], C=spine.ctrl || [(P20[0]+P57[0])/2,(P20[1]+P57[1])/2];
  const P10=gates['10'], P34=gates['34'];
  if(!P20||!P57||!P10||!P34) return;

  // B: intersection of 20–57 curve with horizontal line through Gate 10
  let tB = 1/3;
  const roots = solveQuadForY(P20,C,P57, P10[1]);
  if(roots.length){ tB = roots.reduce((acc,t)=> Math.abs(t-1/3)<Math.abs(acc-1/3)?t:acc, roots[0]); }
  const B = [ (1-tB)**2*P20[0] + 2*(1-tB)*tB*C[0] + tB**2*P57[0],
              (1-tB)**2*P20[1] + 2*(1-tB)*tB*C[1] + tB**2*P57[1] ];

  // A: intersection of 20–57 curve with a line through 34 parallel to "spleen edge" (approx 48→50)
  let tA = 2/3;
  const P48=gates['48'], P50=gates['50'];
  if(P48 && P50){
    const v=[P50[0]-P48[0], P50[1]-P48[1]];
    const ans = findIntersectionWithLine(P20,C,P57, P34, v);
    tA = ans.t;
  }
  const A = [ (1-tA)**2*P20[0] + 2*(1-tA)*tA*C[0] + tA**2*P57[0],
              (1-tA)**2*P20[1] + 2*(1-tA)*tA*C[1] + tA**2*P57[1] ];

  // Piecewise definitions for integration channels
  const pieces = {
    [idKey('10','20')]: [ sample(P20,C,P57, 0.0, Math.min(tB,tA), 28), [B, P10] ],
    [idKey('10','34')]: [ [P10, B], [A, P34] ],
    [idKey('10','57')]: [ [P10, B], sample(P20,C,P57, Math.max(tB,tA), 1.0, 32) ],
    [idKey('57','34')]: [ sample(P20,C,P57, 1.0, tA, 22), [A, P34] ],
    [idKey('20','34')]: [ sample(P20,C,P57, 0.0, tA, 28), [A, P34] ],
    [idKey('20','57')]: [ sample(P20,C,P57, 0.0, 1.0, 40) ]
  };

  function paint(key, cls){
    const segs = pieces[key]; if(!segs) return;
    const w = (layout.channels && layout.channels[key] && layout.channels[key].w) || 8;
    for(const seg of segs){
      const d = Array.isArray(seg[0]) ? pathFromPts(seg) : pathFromPts(seg);
      el('path', Object.assign({'data-id':key, d}, {'class':'channel '+cls, 'stroke-width':w}), gCh);
    }
  }

  // Rule: "entire channel appears defined when both ends defined"
  // We also color by which side defines it (design=blue, personality=black).
  const set = [[10,20],[10,34],[10,57],[57,34],[20,34],[20,57]];
  for(const [a,b] of set){
    const key=idKey(a,b);
    if(both(String(a), String(b))){
      const isDesign = (defs.design.has(String(a)) && defs.design.has(String(b)));
      const cls = isDesign ? 'design' : 'person';
      paint(key, cls);
    }
  }
}

window.applyBodygraph = function(json){
  const defs = { design:new Set(), person:new Set() };
  try{
    (json?.design?.gates||json?.design?.activations||[]).forEach(g=> defs.design.add(String(g.gate||g)));
    (json?.personality?.gates||json?.personality?.activations||[]).forEach(g=> defs.person.add(String(g.gate||g)));
  }catch(e){}
  redraw(defs);
};

async function redraw(defs){
  const layout = await (await fetch('bodygraph-layout.json',{cache:'no-store'})).json();
  drawCenters(layout.centers||[]);
  drawGates(layout.gates||{}, layout.gateRadius||{});
  drawChannels(layout, defs || {design:new Set(), person:new Set()});
}

// initial no-activation draw
redraw();
</script>
</body>
</html>
